#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include <stdlib.h>

#define F_CPU 16000000UL
#define BAUD 9600
#define MYUBRR F_CPU/16/BAUD-1

// Definición de pines para el motor
#define MOTOR_DIR_PIN PB0
#define MOTOR_PWM_PIN PB1

void UART_init(unsigned int ubrr) {
	UBRR0H = (unsigned char)(ubrr >> 8);
	UBRR0L = (unsigned char) ubrr;
	UCSR0B = (1 << RXEN0) | (1 << TXEN0);  // Habilitar RX y TX
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // Formato 8 bits
}

void UART_sendChar(char data) {
	while (!(UCSR0A & (1 << UDRE0)));  // Esperar a que el buffer esté listo
	UDR0 = data;
}

void UART_sendString(const char *str) {
	while (*str) {
		UART_sendChar(*str++);
	}
}

void setupADC() {
	ADMUX |= (1 << REFS0); // Referencia AVcc
	ADMUX &= ~(1 << ADLAR); // Justificación a la derecha
	ADCSRA |= (1 << ADPS2) | (1 << ADPS1); // Prescaler de 64
	ADCSRA |= (1 << ADEN); // Habilitar ADC
}

uint16_t readADC(uint8_t channel) {
	ADMUX = (ADMUX & 0xF0) | (channel & 0x0F); // Seleccionar canal
	ADCSRA |= (1 << ADSC);  // Iniciar conversión
	while (ADCSRA & (1 << ADSC));  // Esperar a que finalice la conversión
	return ADC;  // Retornar valor ADC
}

void setupPWM() {
	// Configurar PWM en el pin OC1A (PB1) y dirección del motor en PB0
	TCCR1A |= (1 << COM1A1) | (1 << WGM11); // Modo Fast PWM, salida en OC1A
	TCCR1B |= (1 << WGM12) | (1 << WGM13) | (1 << CS11); // Prescaler 8
	ICR1 = 255; // Definir tope del contador
	DDRB |= (1 << MOTOR_PWM_PIN) | (1 << MOTOR_DIR_PIN);  // PB1 como salida PWM, PB0 como dirección
}

void setMotorDirection(uint8_t direction) {
	if (direction) {
		PORTB |= (1 << MOTOR_DIR_PIN);  // Sentido horario
		} else {
		PORTB &= ~(1 << MOTOR_DIR_PIN); // Sentido antihorario
	}
}

void setPWM(uint8_t value) {
	OCR1A = value;  // Ajustar ciclo de trabajo PWM
}

int main(void) {
	uint16_t pot1_value, pot2_value;
	uint8_t pwm_value;
	char buffer[64];
	uint8_t direction;

	UART_init(MYUBRR);  // Inicializar UART
	setupADC();         // Inicializar ADC
	setupPWM();         // Inicializar PWM

	while (1) {
		// Leer valores de los dos potenciómetros
		pot1_value = readADC(0);  // Potenciómetro 1 (referencia)
		pot2_value = readADC(1);  // Potenciómetro 2 (motor)

		// Calcular PWM y dirección del motor
		if (pot1_value > pot2_value) {
			direction = 1;  // Sentido horario
			pwm_value = ((pot1_value - pot2_value) * 255) / 1023;  // Ajuste proporcional
			} else if (pot1_value < pot2_value) {
			direction = 0;  // Sentido antihorario
			pwm_value = ((pot2_value - pot1_value) * 255) / 1023;  // Ajuste proporcional
			} else {
			pwm_value = 0;  // Detener el motor si los valores son iguales
		}

		// Ajustar dirección y PWM del motor
		setMotorDirection(direction);
		setPWM(pwm_value);

		// Enviar datos por UART
		snprintf(buffer, sizeof(buffer), "Pot1: %u, Pot2: %u, PWM: %u, Dir: %s\r\n",
		pot1_value, pot2_value, pwm_value, direction ? "Horario" : "Antihorario");
		UART_sendString(buffer);
		UART_sendString("\r\n");
		_delay_ms(100);  // Esperar 100 ms antes de la siguiente iteración
	}

	return 0;
}
